import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk for fetching posts
export const fetchPosts = createAsyncThunk(
  'posts/fetchPosts',
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=10');
      if (!response.ok) {
        throw new Error('Failed to fetch posts');
      }
      const posts = await response.json();
      return posts;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Async thunk for fetching a single post
export const fetchPostById = createAsyncThunk(
  'posts/fetchPostById',
  async (postId, { rejectWithValue }) => {
    try {
      const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch post');
      }
      const post = await response.json();
      return post;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Async thunk for creating a new post
export const createPost = createAsyncThunk(
  'posts/createPost',
  async (postData, { rejectWithValue, getState }) => {
    try {
      const { user } = getState();
      const newPost = {
        ...postData,
        userId: user.userData?.id || 1,
        id: Date.now(), // In real app, this would be generated by the server
      };
      
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      return newPost;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Async thunk for updating a post
export const updatePost = createAsyncThunk(
  'posts/updatePost',
  async ({ postId, updates }, { rejectWithValue }) => {
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 800));
      
      return { postId, updates };
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Async thunk for deleting a post
export const deletePost = createAsyncThunk(
  'posts/deletePost',
  async (postId, { rejectWithValue }) => {
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      
      return postId;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const postsSlice = createSlice({
  name: 'posts',
  initialState: {
    posts: [],
    currentPost: null,
    status: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
    error: null,
    filters: {
      search: '',
      category: 'all',
      sortBy: 'date', // 'date', 'title', 'author'
      sortOrder: 'desc', // 'asc', 'desc'
    },
    pagination: {
      currentPage: 1,
      totalPages: 1,
      itemsPerPage: 10,
      totalItems: 0,
    },
    // Cache for individual posts
    postCache: {},
    // User's draft posts
    drafts: [],
    // User's favorite posts
    favorites: [],
  },
  reducers: {
    // Filter and search actions
    setSearchFilter: (state, action) => {
      state.filters.search = action.payload;
      state.pagination.currentPage = 1; // Reset to first page when searching
    },
    setCategoryFilter: (state, action) => {
      state.filters.category = action.payload;
      state.pagination.currentPage = 1;
    },
    setSortBy: (state, action) => {
      state.filters.sortBy = action.payload;
    },
    setSortOrder: (state, action) => {
      state.filters.sortOrder = action.payload;
    },
    clearFilters: (state) => {
      state.filters = {
        search: '',
        category: 'all',
        sortBy: 'date',
        sortOrder: 'desc',
      };
      state.pagination.currentPage = 1;
    },
    
    // Pagination actions
    setCurrentPage: (state, action) => {
      state.pagination.currentPage = action.payload;
    },
    setItemsPerPage: (state, action) => {
      state.pagination.itemsPerPage = action.payload;
      state.pagination.currentPage = 1; // Reset to first page
    },
    
    // Post management actions
    clearCurrentPost: (state) => {
      state.currentPost = null;
    },
    clearError: (state) => {
      state.error = null;
    },
    
    // Draft management
    saveDraft: (state, action) => {
      const draft = {
        id: action.payload.id || Date.now(),
        ...action.payload,
        savedAt: new Date().toISOString(),
      };
      
      const existingIndex = state.drafts.findIndex(d => d.id === draft.id);
      if (existingIndex >= 0) {
        state.drafts[existingIndex] = draft;
      } else {
        state.drafts.push(draft);
      }
    },
    deleteDraft: (state, action) => {
      state.drafts = state.drafts.filter(draft => draft.id !== action.payload);
    },
    clearDrafts: (state) => {
      state.drafts = [];
    },
    
    // Favorites management
    toggleFavorite: (state, action) => {
      const postId = action.payload;
      const isFavorite = state.favorites.includes(postId);
      
      if (isFavorite) {
        state.favorites = state.favorites.filter(id => id !== postId);
      } else {
        state.favorites.push(postId);
      }
    },
    clearFavorites: (state) => {
      state.favorites = [];
    },
    
    // Cache management
    clearCache: (state) => {
      state.postCache = {};
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch posts
      .addCase(fetchPosts.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.posts = action.payload;
        state.pagination.totalItems = action.payload.length;
        state.pagination.totalPages = Math.ceil(action.payload.length / state.pagination.itemsPerPage);
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      })
      
      // Fetch post by ID
      .addCase(fetchPostById.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(fetchPostById.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.currentPost = action.payload;
        // Cache the post
        state.postCache[action.payload.id] = action.payload;
      })
      .addCase(fetchPostById.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      })
      
      // Create post
      .addCase(createPost.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(createPost.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.posts.unshift(action.payload);
        state.pagination.totalItems += 1;
        state.pagination.totalPages = Math.ceil(state.pagination.totalItems / state.pagination.itemsPerPage);
      })
      .addCase(createPost.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      })
      
      // Update post
      .addCase(updatePost.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(updatePost.fulfilled, (state, action) => {
        state.status = 'succeeded';
        const { postId, updates } = action.payload;
        
        // Update in posts array
        const postIndex = state.posts.findIndex(post => post.id === postId);
        if (postIndex !== -1) {
          state.posts[postIndex] = { ...state.posts[postIndex], ...updates };
        }
        
        // Update current post if it's the one being updated
        if (state.currentPost && state.currentPost.id === postId) {
          state.currentPost = { ...state.currentPost, ...updates };
        }
        
        // Update cache
        if (state.postCache[postId]) {
          state.postCache[postId] = { ...state.postCache[postId], ...updates };
        }
      })
      .addCase(updatePost.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      })
      
      // Delete post
      .addCase(deletePost.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(deletePost.fulfilled, (state, action) => {
        state.status = 'succeeded';
        const postId = action.payload;
        
        // Remove from posts array
        state.posts = state.posts.filter(post => post.id !== postId);
        
        // Clear current post if it's the one being deleted
        if (state.currentPost && state.currentPost.id === postId) {
          state.currentPost = null;
        }
        
        // Remove from cache
        delete state.postCache[postId];
        
        // Remove from favorites
        state.favorites = state.favorites.filter(id => id !== postId);
        
        // Update pagination
        state.pagination.totalItems -= 1;
        state.pagination.totalPages = Math.ceil(state.pagination.totalItems / state.pagination.itemsPerPage);
      })
      .addCase(deletePost.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      });
  },
});

export const {
  setSearchFilter,
  setCategoryFilter,
  setSortBy,
  setSortOrder,
  clearFilters,
  setCurrentPage,
  setItemsPerPage,
  clearCurrentPost,
  clearError,
  saveDraft,
  deleteDraft,
  clearDrafts,
  toggleFavorite,
  clearFavorites,
  clearCache,
} = postsSlice.actions;

// Selectors
export const selectPosts = (state) => state.posts.posts;
export const selectCurrentPost = (state) => state.posts.currentPost;
export const selectPostsStatus = (state) => state.posts.status;
export const selectPostsError = (state) => state.posts.error;
export const selectPostsFilters = (state) => state.posts.filters;
export const selectPostsPagination = (state) => state.posts.pagination;
export const selectDrafts = (state) => state.posts.drafts;
export const selectFavorites = (state) => state.posts.favorites;
export const selectPostCache = (state) => state.posts.postCache;

// Computed selectors
export const selectFilteredPosts = (state) => {
  const { posts, filters } = state.posts;
  let filtered = [...posts];
  
  // Apply search filter
  if (filters.search) {
    const searchLower = filters.search.toLowerCase();
    filtered = filtered.filter(post => 
      post.title.toLowerCase().includes(searchLower) ||
      post.body.toLowerCase().includes(searchLower)
    );
  }
  
  // Apply category filter (if you have categories)
  if (filters.category !== 'all') {
    // This would filter by category if you have that field
    // filtered = filtered.filter(post => post.category === filters.category);
  }
  
  // Apply sorting
  filtered.sort((a, b) => {
    let aValue, bValue;
    
    switch (filters.sortBy) {
      case 'title':
        aValue = a.title.toLowerCase();
        bValue = b.title.toLowerCase();
        break;
      case 'author':
        aValue = a.userId;
        bValue = b.userId;
        break;
      case 'date':
      default:
        aValue = new Date(a.id); // Using id as proxy for date
        bValue = new Date(b.id);
        break;
    }
    
    if (filters.sortOrder === 'asc') {
      return aValue > bValue ? 1 : -1;
    } else {
      return aValue < bValue ? 1 : -1;
    }
  });
  
  return filtered;
};

export const selectPaginatedPosts = (state) => {
  const filtered = selectFilteredPosts(state);
  const { currentPage, itemsPerPage } = state.posts.pagination;
  
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  
  return filtered.slice(startIndex, endIndex);
};

export const selectIsPostFavorite = (postId) => (state) => 
  state.posts.favorites.includes(postId);

export default postsSlice.reducer;
